# Monolithic MAC Stokes Solver (2D)

Этот решатель реализует линейную задачу Стокса в постановке кюветы (lid-driven cavity) на MAC-сетке с монолитной СЛАУ для `u^{n+1}, v^{n+1}, p^{n+1}`.

## Непрерывная модель

\[
\frac{\partial u}{\partial t} - \nu \Delta u + \frac{\partial p}{\partial x} = f_1,\quad
\frac{\partial v}{\partial t} - \nu \Delta v + \frac{\partial p}{\partial y} = f_2,\quad
\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}=0.
\]

Схема по времени: backward Euler (1-й порядок).
Схема по пространству: центральные разности (2-й порядок).

## MAC-размещение

- `p[i,j]`, `i=0..Nx-1`, `j=0..Ny-1` (центры ячеек), размер `Nx x Ny`
- `u[i,j]`, `i=0..Nx`, `j=0..Ny-1` (вертикальные грани), размер `(Nx+1) x Ny`
- `v[i,j]`, `i=0..Nx-1`, `j=0..Ny` (горизонтальные грани), размер `Nx x (Ny+1)`

Шаги сетки: `dx=Lx/Nx`, `dy=Ly/Ny`.

## Граничные условия (кювета)

- Верхняя стенка: `u=U_lid=1`, `v=0`
- Остальные стенки: `u=0`, `v=0`
- Давление: калибровка `p[0,0]=0` (для единственности)

В коде no-slip на верхней стенке для `u` учитывается через ghost-формулу в лапласиане (в RHS уравнения для верхнего ряда `u`).

## Монолитная СЛАУ

На шаге `n->n+1` решается:

\[
\begin{pmatrix}
\frac{1}{dt}I-\nu L_u & 0 & G_x \\
0 & \frac{1}{dt}I-\nu L_v & G_y \\
D_x & D_y & 0
\end{pmatrix}
\begin{pmatrix}
u^{n+1}\\ v^{n+1}\\ p^{n+1}
\end{pmatrix}
=
\begin{pmatrix}
\frac{1}{dt}u^n + f_1 \\
\frac{1}{dt}v^n + f_2 \\
0
\end{pmatrix}.
\]

## Сеточные уравнения по всем случаям

Ниже `u_{i,j}` означает `u(i+1/2,j)`, `v_{i,j}` означает `v(i,j+1/2)`, `p_{i,j}` — центр ячейки.

### 1) Уравнения для `u`-узлов (`i=1..Nx-1`, `j=0..Ny-1`)

Общая форма:
\[
\frac{u^{n+1}_{i,j}-u^n_{i,j}}{dt}
-\nu(\delta_{xx}u^{n+1}_{i,j}+\delta_{yy}u^{n+1}_{i,j})
+\frac{p^{n+1}_{i,j}-p^{n+1}_{i-1,j}}{dx}
= f_1(x_i,y_j,t^{n+1}).
\]

#### Внутренний по `y` (`1 \le j \le Ny-2`)
\[
\delta_{xx}u_{i,j}=\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{dx^2},\quad
\delta_{yy}u_{i,j}=\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{dy^2}.
\]

#### Нижняя граница (`j=0`, no-slip `u=0`)
Ghost: `u_{i,-1}=-u_{i,0}`:
\[
\delta_{yy}u_{i,0}=\frac{u_{i,1}-3u_{i,0}}{dy^2}.
\]

#### Верхняя крышка (`j=Ny-1`, `u=U_lid`)
Ghost: `u_{i,Ny}=2U_{lid}-u_{i,Ny-1}`:
\[
\delta_{yy}u_{i,Ny-1}
=\frac{u_{i,Ny-2}-3u_{i,Ny-1}}{dy^2}
+\frac{2U_{lid}}{dy^2}.
\]
Последний член `2*nu*U_lid/dy^2` переносится в RHS.

### 2) Уравнения для `v`-узлов (`i=0..Nx-1`, `j=1..Ny-1`)

Общая форма:
\[
\frac{v^{n+1}_{i,j}-v^n_{i,j}}{dt}
-\nu(\delta_{xx}v^{n+1}_{i,j}+\delta_{yy}v^{n+1}_{i,j})
+\frac{p^{n+1}_{i,j}-p^{n+1}_{i,j-1}}{dy}
= f_2(x_i,y_j,t^{n+1}).
\]

#### Внутренний по `x` (`1 \le i \le Nx-2`)
\[
\delta_{xx}v_{i,j}=\frac{v_{i+1,j}-2v_{i,j}+v_{i-1,j}}{dx^2}.
\]

#### Левая/правая стенки (`i=0` или `i=Nx-1`, no-slip `v=0`)
Ghost:
\[
\delta_{xx}v_{i,j}\ \Rightarrow\ \frac{v_{\text{neighbor},j}-3v_{i,j}}{dx^2}.
\]

#### По `y` (`j=1..Ny-1`, при `v(i,0)=v(i,Ny)=0`)
\[
\delta_{yy}v_{i,j}=
\frac{v_{i,j+1}-2v_{i,j}+v_{i,j-1}}{dy^2},
\]
а отсутствующие по индексу соседи на `j=0` или `j=Ny` равны нулю.

### 3) Уравнения несжимаемости в центрах `p` (`i=0..Nx-1`, `j=0..Ny-1`)

\[
\frac{u^{n+1}_{i+1,j}-u^{n+1}_{i,j}}{dx}
+\frac{v^{n+1}_{i,j+1}-v^{n+1}_{i,j}}{dy}=0.
\]

Это 2-й порядок на MAC-сетке (центральная аппроксимация divergence).

### 4) Калибровка давления

Вместо уравнения divergence в одной ячейке (`i=0,j=0`) ставится:
\[
p_{0,0}=0.
\]
Это устраняет неопределенность давления по константе.

## Глобальная нумерация неизвестных

В монолитном векторе:

- сначала все `u`-неизвестные (`i=1..Nx-1`, `j=0..Ny-1`): `nu_unknowns=(Nx-1)*Ny`
- затем все `v`-неизвестные (`i=0..Nx-1`, `j=1..Ny-1`): `nv_unknowns=Nx*(Ny-1)`
- затем все `p`-узлы: `np_unknowns=Nx*Ny`

Соответствующие функции в коде:

- `u_unknown_idx(i,j)`
- `v_unknown_idx(i,j)`
- `p_unknown_idx(i,j)`

Они переводят сеточные индексы `(i,j)` в индекс строки/столбца глобальной матрицы.

## Что рисует Python

`main.py`:
- запускает C++ шаги во времени,
- строит GIF эволюции (`velocity + pressure contour`),
- строит отдельный PNG `max|div(u)|` от времени.
